// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: queries.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createDepartment = `-- name: CreateDepartment :one
INSERT INTO departments (
    name, code, tenant_id
) VALUES ( $1, $2, $3)
RETURNING id, name, code, tenant_id
`

type CreateDepartmentParams struct {
	Name     string      `json:"name"`
	Code     string      `json:"code"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) CreateDepartment(ctx context.Context, arg CreateDepartmentParams) (Department, error) {
	row := q.db.QueryRow(ctx, createDepartment, arg.Name, arg.Code, arg.TenantID)
	var i Department
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.TenantID,
	)
	return i, err
}

const createEmployee = `-- name: CreateEmployee :one
INSERT INTO employees (
    email, user_name, tenant_id, department_id
) VALUES ( $1, $2, $3, $3)
RETURNING id, email, user_name, tenant_id, manager_id, department_id
`

type CreateEmployeeParams struct {
	Email    string      `json:"email"`
	UserName string      `json:"user_name"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) CreateEmployee(ctx context.Context, arg CreateEmployeeParams) (Employee, error) {
	row := q.db.QueryRow(ctx, createEmployee, arg.Email, arg.UserName, arg.TenantID)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.UserName,
		&i.TenantID,
		&i.ManagerID,
		&i.DepartmentID,
	)
	return i, err
}

type CreateEmployeesParams struct {
	Email        string      `json:"email"`
	UserName     string      `json:"user_name"`
	TenantID     pgtype.UUID `json:"tenant_id"`
	DepartmentID pgtype.Int2 `json:"department_id"`
}

const createTenant = `-- name: CreateTenant :one
INSERT INTO tenants (
    name, status, code 
) VALUES ( $1, $2, $3)
RETURNING id, name, status, code, size, created_at, updated_at
`

type CreateTenantParams struct {
	Name   string      `json:"name"`
	Status bool        `json:"status"`
	Code   pgtype.Text `json:"code"`
}

func (q *Queries) CreateTenant(ctx context.Context, arg CreateTenantParams) (Tenant, error) {
	row := q.db.QueryRow(ctx, createTenant, arg.Name, arg.Status, arg.Code)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Status,
		&i.Code,
		&i.Size,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

type CreateTenantsParams struct {
	Name   string      `json:"name"`
	Status bool        `json:"status"`
	Code   pgtype.Text `json:"code"`
}

const getCountEmployeeWithGivenDeptCodeInTenant = `-- name: GetCountEmployeeWithGivenDeptCodeInTenant :one
SELECT COUNT (
    *
    )
FROM employees
INNER JOIN departments ON departments.id = employees.department_id
WHERE 
employees.tenant_id = $1 AND
departments.code = $2
`

type GetCountEmployeeWithGivenDeptCodeInTenantParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Code     string      `json:"code"`
}

func (q *Queries) GetCountEmployeeWithGivenDeptCodeInTenant(ctx context.Context, arg GetCountEmployeeWithGivenDeptCodeInTenantParams) (int64, error) {
	row := q.db.QueryRow(ctx, getCountEmployeeWithGivenDeptCodeInTenant, arg.TenantID, arg.Code)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getDepartmentID = `-- name: GetDepartmentID :many
SELECT id FROM departments
`

func (q *Queries) GetDepartmentID(ctx context.Context) ([]int16, error) {
	rows, err := q.db.Query(ctx, getDepartmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int16
	for rows.Next() {
		var id int16
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmployeeWithGivenDeptCodeInTenant = `-- name: GetEmployeeWithGivenDeptCodeInTenant :many
SELECT
    employees.id,
    employees.email,
    employees.user_name,
    employees.tenant_id,
    employees.manager_id,
    employees.department_id,
    -- departments.id,
    departments.name,
    departments.code
FROM employees
INNER JOIN departments ON departments.id = employees.department_id
WHERE 
employees.tenant_id = $1 AND
departments.code = $2
`

type GetEmployeeWithGivenDeptCodeInTenantParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Code     string      `json:"code"`
}

type GetEmployeeWithGivenDeptCodeInTenantRow struct {
	ID           pgtype.UUID `json:"id"`
	Email        string      `json:"email"`
	UserName     string      `json:"user_name"`
	TenantID     pgtype.UUID `json:"tenant_id"`
	ManagerID    pgtype.UUID `json:"manager_id"`
	DepartmentID pgtype.Int2 `json:"department_id"`
	Name         string      `json:"name"`
	Code         string      `json:"code"`
}

func (q *Queries) GetEmployeeWithGivenDeptCodeInTenant(ctx context.Context, arg GetEmployeeWithGivenDeptCodeInTenantParams) ([]GetEmployeeWithGivenDeptCodeInTenantRow, error) {
	rows, err := q.db.Query(ctx, getEmployeeWithGivenDeptCodeInTenant, arg.TenantID, arg.Code)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEmployeeWithGivenDeptCodeInTenantRow
	for rows.Next() {
		var i GetEmployeeWithGivenDeptCodeInTenantRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.UserName,
			&i.TenantID,
			&i.ManagerID,
			&i.DepartmentID,
			&i.Name,
			&i.Code,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTenantIDFromName = `-- name: GetTenantIDFromName :one
SELECT id FROM tenants
WHERE name = $1
`

func (q *Queries) GetTenantIDFromName(ctx context.Context, name string) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, getTenantIDFromName, name)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const getTentantID = `-- name: GetTentantID :many
SELECT id FROM tenants
`

func (q *Queries) GetTentantID(ctx context.Context) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, getTentantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var id pgtype.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEmployeFromEmail = `-- name: UpdateEmployeFromEmail :one
UPDATE employees
SET
    user_name = COALESCE($1,user_name),
    manager_id = COALESCE($2,manager_id),
    department_id = COALESCE($3,department_id)
WHERE email = $4
RETURNING id, email, user_name, tenant_id, manager_id, department_id
`

type UpdateEmployeFromEmailParams struct {
	UserName     pgtype.Text `json:"user_name"`
	ManagerID    pgtype.UUID `json:"manager_id"`
	DepartmentID pgtype.Int2 `json:"department_id"`
	Email        string      `json:"email"`
}

func (q *Queries) UpdateEmployeFromEmail(ctx context.Context, arg UpdateEmployeFromEmailParams) (Employee, error) {
	row := q.db.QueryRow(ctx, updateEmployeFromEmail,
		arg.UserName,
		arg.ManagerID,
		arg.DepartmentID,
		arg.Email,
	)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.UserName,
		&i.TenantID,
		&i.ManagerID,
		&i.DepartmentID,
	)
	return i, err
}
